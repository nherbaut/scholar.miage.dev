<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Works → References (forward & backward)</title>
  <style>
    :root{
      --bg:#0b0f14; --fg:#e6edf3; --muted:#9fb0c0;
      --work:#7aa2f7;            /* works (middle ring) */
      --ref:#f7768e;             /* forward refs (center) */
      --ref-back:#94e2d5;        /* backward refs (outer ring) */
      --work-neigh:#22c55e;      /* highlight works  */
      --ref-neigh:#f59e0b;       /* highlight forward refs */
      --ref-back-neigh:#10b981;  /* highlight backward refs */
      --link:#6b7280; --panel:#10151c; --accent:#a6e3a1;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica,Arial}
    #app{display:grid;grid-template-rows:auto 1fr;height:100%}
    header{display:flex;gap:.75rem;align-items:center;padding:.6rem .9rem;background:var(--panel);border-bottom:1px solid #1b2530;position:sticky;top:0;z-index:2}
    header button{background:#182330;color:var(--fg);border:1px solid #2a394b;padding:.45rem .7rem;border-radius:.5rem;cursor:pointer;font-size:14px}
    header button:hover{border-color:#3b516b}
    header .group{display:flex;align-items:center;gap:.35rem;font-size:12px;color:var(--muted)}
    header input[type=range]{width:180px;vertical-align:middle}
    header .meta{font-size:12px;color:var(--muted);margin-left:.5rem}
    #container{position:relative}
    svg{width:100%;height:100%;display:block}

    .link{stroke:var(--link);stroke-opacity:.35}
    .link.highlight{stroke-opacity:.85}
    .link.back{stroke-dasharray:5 4}

    .node{stroke:#0a0f14;stroke-width:1px;cursor:grab}
    .node:active{cursor:grabbing}
    .node.work{fill:var(--work)}
    .node.ref{fill:var(--ref)}
    .node.ref_back{fill:var(--ref-back)}

    .node.work.neighbor{fill:var(--work-neigh)}
    .node.ref.neighbor{fill:var(--ref-neigh)}
    .node.ref_back.neighbor{fill:var(--ref-back-neigh)}

    .label{pointer-events:none;font-size:11px;fill:#cdd6f4;opacity:.85}
    .legend{position:absolute;left:10px;bottom:10px;background:rgba(16,21,28,.9);border:1px solid #24303d;border-radius:8px;padding:.5rem .7rem;font-size:12px}
    .legend .swatch{width:.75rem;height:.75rem;display:inline-block;border-radius:999px;margin-right:.35rem;vertical-align:middle}

    #tooltip{position:absolute;z-index:10;pointer-events:none;background:#111827;color:var(--fg);border:1px solid #253244;border-radius:.5rem;padding:.6rem .7rem;max-width:420px;box-shadow:0 10px 30px rgba(0,0,0,.35);display:none}
    #tooltip h3{margin:0 0 .35rem 0;font-size:14px}
    #tooltip .row{font-size:12px;color:var(--muted);margin-top:.25rem}
    #tooltip a{color:var(--accent);text-decoration:none}
    #tooltip a:hover{text-decoration:underline}

    .ring{fill:none;stroke:#223042;stroke-dasharray:4 6;stroke-opacity:.5}
  </style>
</head>
<body>
  <div id="app">
    <header>
      <button id="btn-reset" title="Reset nodes to initial layout">Reset layout</button>
      <button id="btn-fit" title="Zoom/Pan to fit graph">Fit to view</button>
      <button id="btn-download" title="Download JSON">Download JSON</button>
      <div class="group">Threshold (forward)
        <!-- forward min threshold is 2 -->
        <input id="thFwd" type="range" min="2" max="20" value="2" />
        <span id="thFwdVal">2</span>
      </div>
      <div class="group">Threshold (backward)
        <input id="thBack" type="range" min="1" max="20" value="1" />
        <span id="thBackVal">1</span>
      </div>
      <div class="meta" id="meta">Loading…</div>
    </header>
    <div id="container">
      <svg id="svg" viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid meet"></svg>
      <div class="legend">
        <div><span class="swatch" style="background: var(--ref)"></span>Forward references (center)</div>
        <div><span class="swatch" style="background: var(--work)"></span>Input works (middle ring)</div>
        <div><span class="swatch" style="background: var(--ref-back)"></span>Backward refs (outer ring)</div>
      </div>
      <div id="tooltip"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
  const svg = d3.select('#svg');
  const width = 1200, height = 800;

  const gZoom  = svg.append('g');
  const gRings = gZoom.append('g');
  const gLinks = gZoom.append('g');
  const gNodes = gZoom.append('g');
  const gLabels= gZoom.append('g');

  const tooltip  = document.getElementById('tooltip');
  const metaEl   = document.getElementById('meta');
  const thFwdEl  = document.getElementById('thFwd');
  const thBackEl = document.getElementById('thBack');
  const thFwdVal = document.getElementById('thFwdVal');
  const thBackVal= document.getElementById('thBackVal');
  const btnDownload = document.getElementById('btn-download');

  let fullData = null;
  // Data URL (backend-provided ID must be templated on server side)
  const DATA_URL = '/network/compute/{{work_list_id}}';
  let currentDataURL = DATA_URL;

  const zoom = d3.zoom().scaleExtent([0.25, 3]).on('zoom', (ev)=>{ gZoom.attr('transform', ev.transform); });
  svg.call(zoom);

  // Simulation for CENTER refs only (forward).
  const sim = d3.forceSimulation()
    .force('charge', d3.forceManyBody().strength(-40))
    .force('center', d3.forceCenter(width/2, height/2))
    .force('collide', d3.forceCollide().radius(d => d.type === 'ref' ? 18 + Math.sqrt(d.count || 1)*2 : 10))
    .alphaDecay(0.05);

  function computeInitialPositions(data){
    const cx = width/2, cy = height/2;
    const works    = data.nodes.filter(n => n.type === 'work');
    const refs     = data.nodes.filter(n => n.type === 'ref');
    const refsBack = data.nodes.filter(n => n.type === 'ref_back');

    const R_work = Math.min(width, height) * 0.42; // middle ring
    const R_back = Math.min(width, height) * 0.50; // outer ring

    // Works on middle ring (pinned)
    works.forEach((n, i) => {
      const theta = (i / Math.max(1, works.length)) * 2 * Math.PI;
      const x = cx + R_work * Math.cos(theta);
      const y = cy + R_work * Math.sin(theta);
      n.x = n.fx = x; n.y = n.fy = y;
      n.initialX = x; n.initialY = y;
    });

    // Forward refs near center (free, simulated)
    refs.forEach(n => {
      const jitter = 40;
      n.x = cx + (Math.random()-0.5)*jitter;
      n.y = cy + (Math.random()-0.5)*jitter;
      n.initialX = n.x; n.initialY = n.y;
      n.fx = null; n.fy = null;
    });

    // Backward refs on outer ring (pinned)
    refsBack.forEach((n, i) => {
      const theta = (i / Math.max(1, refsBack.length)) * 2 * Math.PI;
      const x = cx + R_back * Math.cos(theta);
      const y = cy + R_back * Math.sin(theta);
      n.x = n.fx = x; n.y = n.fy = y;
      n.initialX = x; n.initialY = y;
    });

    // Draw rings
    gRings.selectAll('circle').data([R_work, R_back])
      .join(
        enter => enter.append('circle').attr('class','ring')
          .attr('cx', cx).attr('cy', cy).attr('r', d => d),
        update => update.attr('r', d => d),
        exit => exit.remove()
      );
  }

  function render(data, thFwd, thBack){
    // Keep refs by separate thresholds
    const refsKept     = new Set(data.nodes.filter(n => n.type==='ref'      && (n.count||0) >= thFwd).map(n=>n.id));
    const refsBackKept = new Set(data.nodes.filter(n => n.type==='ref_back' && (n.count||0) >= thBack).map(n=>n.id));
    const filteredNodes = data.nodes.filter(n =>
      n.type === 'work' || refsKept.has(n.id) || refsBackKept.has(n.id)
    );

    const filteredLinks = data.links.filter(l => {
      const t = String(typeof l.target === 'object' ? l.target.id : l.target);
      return refsKept.has(t) || refsBackKept.has(t);
    });

    // Adjacency maps
    const refsByWorkFwd   = new Map(); // workId -> Set(refIds)
    const refsByWorkBack  = new Map(); // workId -> Set(refBackIds)
    const worksByRefFwd   = new Map(); // refId      -> Set(workIds)
    const worksByRefBack  = new Map(); // refBackId  -> Set(workIds)

    const nodeIds = new Set(filteredNodes.map(n => String(n.id)));

    for(const l of filteredLinks){
      const s = String(typeof l.source === 'object' ? l.source.id : l.source);
      const t = String(typeof l.target === 'object' ? l.target.id : l.target);
      const kind = (l.kind === 'back') ? 'back' : 'forward';
      if(!nodeIds.has(s)) continue;

      if(kind === 'forward'){
        if(!refsByWorkFwd.has(s)) refsByWorkFwd.set(s, new Set());
        if(!worksByRefFwd.has(t)) worksByRefFwd.set(t, new Set());
        refsByWorkFwd.get(s).add(t);
        worksByRefFwd.get(t).add(s);
      }else{
        if(!refsByWorkBack.has(s)) refsByWorkBack.set(s, new Set());
        if(!worksByRefBack.has(t)) worksByRefBack.set(t, new Set());
        refsByWorkBack.get(s).add(t);
        worksByRefBack.get(t).add(s);
      }
    }

    // Work sizing by number of backward citations currently displayed
    const workIds = filteredNodes.filter(n => n.type === 'work').map(n => String(n.id));
    const workCiteCount = new Map(workIds.map(id => [id, 0]));
    for (const [refb, ws] of worksByRefBack.entries()) {
      for (const w of ws) {
        if (workCiteCount.has(w)) workCiteCount.set(w, workCiteCount.get(w) + 1);
      }
    }
    const maxCites = Math.max(1, ...workIds.map(id => workCiteCount.get(id) || 0));
    const workSize = d3.scaleSqrt().domain([0, maxCites]).range([7, 18]);

    metaEl.textContent = `${filteredNodes.length} nodes, ${filteredLinks.length} links (forward≥${thFwd}, backward≥${thBack})`;
    computeInitialPositions({nodes: filteredNodes});

    const refSize = d3.scaleSqrt()
      .domain(d3.extent(filteredNodes.filter(d => d.type==='ref').map(d => d.count || 1)) || [1,1])
      .range([8, 24]);

    // Links
    const link = gLinks.selectAll('line').data(filteredLinks, d => {
      const s = String(typeof d.source === 'object' ? d.source.id : d.source);
      const t = String(typeof d.target === 'object' ? d.target.id : d.target);
      return `${s}->${t}->${d.kind||'forward'}`;
    });
    link.join(
      enter => enter.append('line')
        .attr('class', d => `link ${d.kind === 'back' ? 'back' : ''}`)
        .attr('stroke-width', 1.2),
      update => update.attr('class', d => `link ${d.kind === 'back' ? 'back' : ''}`),
      exit => exit.remove()
    );

    // Nodes
    const node = gNodes.selectAll('circle').data(filteredNodes, d => d.id);
    node.join(
      enter => enter.append('circle')
        .attr('class', d => `node ${d.type}`)
        .attr('r', d =>
          d.type === 'ref' ? refSize(d.count || 1) :
          d.type === 'ref_back' ? 8 :
          workSize(workCiteCount.get(String(d.id)) || 0)
        )
        .call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended))
        .on('mouseover', (ev, d) => { showTooltip(ev, d); applyHighlight(d, true, refsByWorkFwd, worksByRefFwd, refsByWorkBack, worksByRefBack); })
        .on('mousemove', (ev) => { moveTooltip(ev); })
        .on('mouseout',  (ev, d) => { hideTooltip(); applyHighlight(d, false, refsByWorkFwd, worksByRefFwd, refsByWorkBack, worksByRefBack); })
        .on('contextmenu', (ev, d) => { ev.preventDefault(); copyOpenAlex(d); }),
      update => update
        .attr('r', d =>
          d.type === 'ref' ? refSize(d.count || 1) :
          d.type === 'ref_back' ? 8 :
          workSize(workCiteCount.get(String(d.id)) || 0)
        )
        .attr('class', d => `node ${d.type}`),
      exit => exit.remove()
    );

    // Labels (forward refs only)
    const label = gLabels.selectAll('text').data(filteredNodes.filter(d => d.type==='ref'), d => d.id);
    label.join(
      enter => enter.append('text').attr('class','label').attr('text-anchor','middle')
        .attr('dy', d => -(refSize(d.count || 1) + 6)).text(d => truncate(d.title || d.id, 36)),
      update => update.text(d => truncate(d.title || d.id, 36)).attr('dy', d => -(refSize(d.count || 1) + 6)),
      exit => exit.remove()
    );

    // Simulation on forward refs only
    const refNodes = filteredNodes.filter(d => d.type==='ref');
    sim.nodes(refNodes).on('tick', () => {
      gLinks.selectAll('line')
        .attr('x1', d => nodeById(d.source, filteredNodes).x)
        .attr('y1', d => nodeById(d.source, filteredNodes).y)
        .attr('x2', d => nodeById(d.target, filteredNodes).x)
        .attr('y2', d => nodeById(d.target, filteredNodes).y);
      gNodes.selectAll('circle').attr('cx', d => d.x).attr('cy', d => d.y);
      gLabels.selectAll('text').attr('x', d => d.x).attr('y', d => d.y - 2);
    });
  }

  function nodeById(id, nodes){
    const key = String(typeof id === 'object' ? id.id : id);
    return nodes.find(n => String(n.id) === key) || {x:0, y:0};
  }

  function applyHighlight(d, on, refsByWorkFwd, worksByRefFwd, refsByWorkBack, worksByRefBack){
    gNodes.selectAll('circle').classed('neighbor', false);
    gLinks.selectAll('line').classed('highlight', false);
    if(!on) return;

    if(d.type === 'work'){
      const neighF = refsByWorkFwd.get(String(d.id))  || new Set();
      const neighB = refsByWorkBack.get(String(d.id)) || new Set();
      gNodes.selectAll('circle').filter(n => n.type === 'ref' && neighF.has(String(n.id))).classed('neighbor', true);
      gNodes.selectAll('circle').filter(n => n.type === 'ref_back' && neighB.has(String(n.id))).classed('neighbor', true);
      gLinks.selectAll('line').classed('highlight', l => {
        const s = String(typeof l.source === 'object' ? l.source.id : l.source);
        const t = String(typeof l.target === 'object' ? l.target.id : l.target);
        if(s !== String(d.id)) return false;
        return (l.kind === 'back') ? neighB.has(t) : neighF.has(t);
      });

    } else if(d.type === 'ref'){
      const neighW = worksByRefFwd.get(String(d.id)) || new Set();
      gNodes.selectAll('circle').filter(n => n.type === 'work' && neighW.has(String(n.id))).classed('neighbor', true);
      gLinks.selectAll('line').classed('highlight', l => {
        const s = String(typeof l.source === 'object' ? l.source.id : l.source);
        const t = String(typeof l.target === 'object' ? l.target.id : l.target);
        return (l.kind !== 'back') && t === String(d.id) && neighW.has(s);
      });

    } else if(d.type === 'ref_back'){
      const neighW = worksByRefBack.get(String(d.id)) || new Set();
      gNodes.selectAll('circle').filter(n => n.type === 'work' && neighW.has(String(n.id))).classed('neighbor', true);
      gLinks.selectAll('line').classed('highlight', l => {
        const s = String(typeof l.source === 'object' ? l.source.id : l.source);
        const t = String(typeof l.target === 'object' ? l.target.id : l.target);
        return (l.kind === 'back') && t === String(d.id) && neighW.has(s);
      });
    }
  }

  function dragstarted(event, d){ if(!event.active) sim.alpha(0.3).restart(); d.fx = d.x; d.fy = d.y; }
  function dragged(event, d){ d.fx = event.x; d.fy = event.y; }
  function dragended(event, d){ if(d.type === 'ref'){ d.fx = null; d.fy = null; } else { d.fx = d.x; d.fy = d.y; } }

  function showTooltip(ev, d){
    const lines = [];
    if (d.title)   lines.push('<div class="row"><strong>Title:</strong> ' + escapeHTML(d.title) + '</div>');
    if (d.authors && d.authors.length) lines.push('<div class="row"><strong>Authors:</strong> ' + escapeHTML(d.authors.join(', ')) + '</div>');
    if (d.venue)   lines.push('<div class="row"><strong>Venue:</strong> ' + escapeHTML(d.venue) + '</div>');
    if (d.doi)     lines.push('<div class="row"><strong>DOI:</strong> <a href="' + d.doi + '" target="_blank">' + escapeHTML(d.doi) + '</a></div>');
    if (d.openalex)lines.push('<div class="row"><strong>OpenAlex:</strong> <a href="' + d.openalex + '" target="_blank">' + escapeHTML(d.openalex) + '</a></div>');
    if (Number.isFinite(d.count)) lines.push('<div class="row"><strong>Connections to input works:</strong> ' + d.count + '</div>');
    const kind = d.type === 'work' ? 'Work' : (d.type === 'ref_back' ? 'Backward reference' : 'Reference');
    tooltip.innerHTML = '<h3>' + kind + '</h3>' + lines.join('');
    tooltip.style.display = 'block';
    moveTooltip(ev);
  }
  function moveTooltip(ev){ tooltip.style.left = (ev.clientX + 14) + 'px'; tooltip.style.top = (ev.clientY + 14) + 'px'; }
  function hideTooltip(){ tooltip.style.display = 'none'; }

  function copyOpenAlex(d){
    let text = '';
    if (d.openalex) text = d.openalex;
    else if (String(d.id).startsWith('W')) text = 'https://openalex.org/' + d.id;
    if (text) {
      navigator.clipboard.writeText(text).then(() => {
        metaEl.textContent = 'Copied ' + text;
        setTimeout(() => { metaEl.textContent = ''; }, 2000);
      }).catch(()=>{});
    }
  }

  document.getElementById('btn-reset').onclick = () => {
    if (!fullData) return;
    render(fullData, parseInt(thFwdEl.value, 10), parseInt(thBackEl.value, 10));
  };
  document.getElementById('btn-fit').onclick = () => fitToView();

  // Download JSON (forward request to the same data URL)
  btnDownload.onclick = () => {
    const a = document.createElement('a');
    a.href = currentDataURL;
    a.download = 'graph.json';
    document.body.appendChild(a);
    a.click();
    a.remove();
  };

  thFwdEl.oninput = () => {
    thFwdVal.textContent = thFwdEl.value;
    if (fullData) render(fullData, parseInt(thFwdEl.value, 10), parseInt(thBackEl.value, 10));
  };
  thBackEl.oninput = () => {
    thBackVal.textContent = thBackEl.value;
    if (fullData) render(fullData, parseInt(thFwdEl.value, 10), parseInt(thBackEl.value, 10));
  };

  function fitToView(){
    const pad = 40;
    const renderedNodes = Array.from(gNodes.selectAll('circle').data());
    if (renderedNodes.length === 0) return;
    const xs = renderedNodes.map(d => d.x), ys = renderedNodes.map(d => d.y);
    const minX = Math.min(...xs) - pad, maxX = Math.max(...xs) + pad;
    const minY = Math.min(...ys) - pad, maxY = Math.max(...ys) + pad;
    const widthVB = Math.max(1, maxX - minX), heightVB = Math.max(1, maxY - minY);
    const k = Math.min(svg.node().clientWidth / widthVB, svg.node().clientHeight / heightVB);
    svg.transition().duration(450).call(
      zoom.transform,
      d3.zoomIdentity
        .translate(svg.node().clientWidth/2, svg.node().clientHeight/2)
        .scale(isFinite(k) ? k : 1)
        .translate(-(minX + widthVB/2), -(minY + heightVB/2))
    );
  }

  // Initial data fetch
  fetch(DATA_URL)
    .then(r => r.json())
    .then(data => {
      fullData = data;
      currentDataURL = DATA_URL;
      thFwdVal.textContent = thFwdEl.value;
      thBackVal.textContent = thBackEl.value;
      render(fullData, parseInt(thFwdEl.value, 10), parseInt(thBackEl.value, 10));
    })
    .catch(err => { metaEl.textContent = 'Error loading data: ' + err; });

  // Utils
  function truncate(s, n) {
    s = s || '';
    return s.length > n ? s.slice(0, n - 1) + '\u2026' : s;
  }
  function escapeHTML(s) {
    const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' };
    return String(s).replace(/[&<>"']/g, ch => map[ch]);
  }
  </script>
</body>
</html>
